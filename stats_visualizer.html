<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Logan Stats Visualizer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .controls {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
        }
        label {
            font-weight: bold;
            margin-bottom: 5px;
            color: #555;
        }
        select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .stats-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 6px;
            text-align: center;
            border-left: 4px solid #007bff;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #007bff;
        }
        .stat-label {
            color: #666;
            font-size: 14px;
        }
        .chart-container {
            position: relative;
            height: 400px;
            margin-bottom: 30px;
            background: white;
            border-radius: 6px;
            padding: 10px;
        }
        .table-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        .data-table {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid #ddd;
            border-radius: 6px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 10px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        th {
            background: #f8f9fa;
            position: sticky;
            top: 0;
            z-index: 10;
            cursor: pointer;
            user-select: none;
        }
        th:hover {
            background: #e9ecef;
        }
        .sort-indicator {
            margin-left: 5px;
            font-size: 12px;
            color: #666;
        }
        tr:hover {
            background: #f5f5f5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Logan Stats Visualizer</h1>
        
        <div class="controls">
            <div class="control-group">
                <label for="techniqueFilter">Filter by Technique:</label>
                <select id="techniqueFilter">
                    <option value="all">All Techniques</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="typeFilter">Filter by Type:</label>
                <select id="typeFilter">
                    <option value="all">All Types</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="chartType">Chart Type:</label>
                <select id="chartType">
                    <option value="scatter">Size vs Sample Count</option>
                    <option value="bar">Category Summary</option>
                    <option value="histogram">Size Distribution</option>
                    <option value="box">Sample Count Distribution</option>
                </select>
            </div>
            
            <div class="control-group">
                <label for="logScale">Log Scale:</label>
                <select id="logScale">
                    <option value="none">Linear</option>
                    <option value="x">Log X-axis</option>
                    <option value="y">Log Y-axis</option>
                    <option value="both">Log Both Axes</option>
                </select>
            </div>
        </div>

        <div class="stats-panel">
            <div class="stat-card">
                <div class="stat-value" id="totalEntries">0</div>
                <div class="stat-label">Total Entries</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalSize">0</div>
                <div class="stat-label">Total Size (GB)</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="totalSamples">0</div>
                <div class="stat-label">Total Samples</div>
            </div>
            <div class="stat-card">
                <div class="stat-value" id="categoryCount">0</div>
                <div class="stat-label">Categories</div>
            </div>
        </div>

        <div class="chart-container">
            <canvas id="mainChart"></canvas>
        </div>

        <div class="table-controls">
            <div>
                <strong>Data Table</strong> - Click column headers to sort
            </div>
        </div>

        <div class="data-table">
            <table id="dataTable">
                <thead>
                    <tr>
                        <th onclick="sortTable('index')">Index<span class="sort-indicator" id="sort-index"></span></th>
                        <th onclick="sortTable('category')">Category<span class="sort-indicator" id="sort-category"></span></th>
                        <th onclick="sortTable('size')">Size (GB)<span class="sort-indicator" id="sort-size"></span></th>
                        <th onclick="sortTable('sampleCount')">Sample Count<span class="sort-indicator" id="sort-sampleCount"></span></th>
                    </tr>
                </thead>
                <tbody id="tableBody">
                </tbody>
            </table>
        </div>
    </div>

    <script>
        let currentData = [];
        let filteredData = [];
        let currentChart = null;
        let categories = new Set();
        let techniques = new Set();
        let types = new Set();
        let sortState = { column: null, direction: 'asc' };

        const categoryColors = [
            '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF',
            '#FF9F40', '#FF6384', '#C9CBCF', '#4BC0C0', '#FF6384',
            '#36A2EB', '#FFCE56', '#4BC0C0', '#9966FF', '#FF9F40'
        ];

        const defaultData = `METATRANSCRIPTOMIC_BCT_10 0.00201 18
METATRANSCRIPTOMIC_BCT_11 0.00212 73
METATRANSCRIPTOMIC_BCT_12 0.00243 114
METATRANSCRIPTOMIC_BCT_13 0.00308 190
METATRANSCRIPTOMIC_BCT_14 0.00684 424
METATRANSCRIPTOMIC_BCT_15 0.02232 885
METATRANSCRIPTOMIC_BCT_16 0.07270 1541
METATRANSCRIPTOMIC_BCT_17 0.19424 2139
METATRANSCRIPTOMIC_BCT_18 0.64459 3616
METATRANSCRIPTOMIC_BCT_19 1.91000 5413
GENOMIC_VIR_10 0.00150 25
GENOMIC_VIR_11 0.00180 45
GENOMIC_VIR_12 0.00220 80
GENOMIC_VIR_13 0.00280 120
GENOMIC_VIR_14 0.00350 180
TRANSCRIPTOMIC_FUN_10 0.00120 15
TRANSCRIPTOMIC_FUN_11 0.00140 30
TRANSCRIPTOMIC_FUN_12 0.00170 50
TRANSCRIPTOMIC_FUN_13 0.00200 75
TRANSCRIPTOMIC_FUN_14 0.00250 110`;

        function sortTable(column) {
            if (sortState.column === column) {
                sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
            } else {
                sortState.column = column;
                sortState.direction = 'asc';
            }

            filteredData.sort((a, b) => {
                let valueA = a[column];
                let valueB = b[column];

                if (column === 'size' || column === 'sampleCount') {
                    valueA = parseFloat(valueA);
                    valueB = parseFloat(valueB);
                } else {
                    valueA = valueA.toString().toLowerCase();
                    valueB = valueB.toString().toLowerCase();
                }

                if (valueA < valueB) {
                    return sortState.direction === 'asc' ? -1 : 1;
                }
                if (valueA > valueB) {
                    return sortState.direction === 'asc' ? 1 : -1;
                }
                return 0;
            });

            updateSortIndicators();
            updateTable();
        }

        function updateSortIndicators() {
            document.querySelectorAll('.sort-indicator').forEach(el => {
                el.textContent = '';
            });

            if (sortState.column) {
                const indicator = document.getElementById(`sort-${sortState.column}`);
                if (indicator) {
                    indicator.textContent = sortState.direction === 'asc' ? '↑' : '↓';
                }
            }
        }

        function parseData(text) {
            const lines = text.trim().split('\n');
            const data = [];
            categories.clear();
            techniques.clear();
            types.clear();

            lines.forEach(line => {
                const parts = line.trim().split(/\s+/);
                if (parts.length >= 3) {
                    const index = parts[0];
                    const size = parseFloat(parts[1]);
                    const sampleCount = parseInt(parts[2]);
                    
                    const indexParts = index.split('_');
                    let technique = 'OTHER';
                    let type = 'OTHER';
                    let category = 'OTHER';
                    
                    if (indexParts.length >= 2) {
                        technique = indexParts[0];
                        type = indexParts[1];
                        category = technique + '_' + type;
                    }
                    
                    techniques.add(technique);
                    types.add(type);
                    categories.add(category);
                    data.push({ index, category, technique, type, size, sampleCount });
                }
            });

            return data;
        }

        function updateCategoryFilter() {
            const techniqueSelect = document.getElementById('techniqueFilter');
            const typeSelect = document.getElementById('typeFilter');
            
            techniqueSelect.innerHTML = '<option value="all">All Techniques</option>';
            typeSelect.innerHTML = '<option value="all">All Types</option>';
            
            Array.from(techniques).sort().forEach(technique => {
                const option = document.createElement('option');
                option.value = technique;
                option.textContent = technique;
                techniqueSelect.appendChild(option);
            });
            
            Array.from(types).sort().forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                typeSelect.appendChild(option);
            });
        }

        function getFilteredData() {
            const techniqueFilter = document.getElementById('techniqueFilter').value;
            const typeFilter = document.getElementById('typeFilter').value;
            
            return currentData.filter(item => {
                const techniqueMatch = techniqueFilter === 'all' || item.technique === techniqueFilter;
                const typeMatch = typeFilter === 'all' || item.type === typeFilter;
                return techniqueMatch && typeMatch;
            });
        }

        function updateStats() {
            const data = filteredData;
            
            document.getElementById('totalEntries').textContent = data.length;
            document.getElementById('totalSize').textContent = data.length > 0 ? 
                (data.reduce((sum, item) => sum + item.size, 0)).toLocaleString() : '0';
            document.getElementById('totalSamples').textContent = 
                data.reduce((sum, item) => sum + item.sampleCount, 0).toLocaleString();
            
            const uniqueCategories = new Set(data.map(item => item.category)).size;
            document.getElementById('categoryCount').textContent = uniqueCategories;
        }

        function updateTable() {
            const tbody = document.getElementById('tableBody');
            tbody.innerHTML = '';

            filteredData.forEach(item => {
                const row = tbody.insertRow();
                row.insertCell(0).textContent = item.index;
                row.insertCell(1).textContent = item.category;
                row.insertCell(2).textContent = item.size.toFixed(5);
                row.insertCell(3).textContent = item.sampleCount.toLocaleString();
            });
        }

        function createChart() {
            const canvas = document.getElementById('mainChart');
            const ctx = canvas.getContext('2d');
            
            if (currentChart) {
                currentChart.destroy();
            }

            const data = filteredData;
            const chartType = document.getElementById('chartType').value;
            const logScale = document.getElementById('logScale').value;

            let chartConfig = {};

            switch (chartType) {
                case 'scatter':
                    chartConfig = createScatterChart(data, logScale);
                    break;
                case 'bar':
                    chartConfig = createBarChart(data);
                    break;
                case 'histogram':
                    chartConfig = createHistogram(data, 'size', logScale);
                    break;
                case 'box':
                    chartConfig = createHistogram(data, 'sampleCount', logScale);
                    break;
            }

            currentChart = new Chart(ctx, chartConfig);
        }

        function createScatterChart(data, logScale) {
            const datasets = {};
            
            data.forEach(item => {
                if (!datasets[item.category]) {
                    datasets[item.category] = {
                        label: item.category,
                        data: [],
                        backgroundColor: categoryColors[Object.keys(datasets).length % categoryColors.length] + '80',
                        borderColor: categoryColors[Object.keys(datasets).length % categoryColors.length],
                        borderWidth: 1
                    };
                }
                datasets[item.category].data.push({
                    x: item.size,
                    y: item.sampleCount
                });
            });

            return {
                type: 'scatter',
                data: {
                    datasets: Object.values(datasets)
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: logScale === 'x' || logScale === 'both' ? 'logarithmic' : 'linear',
                            title: {
                                display: true,
                                text: 'Size (GB)'
                            }
                        },
                        y: {
                            type: logScale === 'y' || logScale === 'both' ? 'logarithmic' : 'linear',
                            title: {
                                display: true,
                                text: 'Sample Count'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Size vs Sample Count by Category'
                        },
                        legend: {
                            position: 'right'
                        }
                    }
                }
            };
        }

        function createBarChart(data) {
            const categoryStats = {};
            
            data.forEach(item => {
                if (!categoryStats[item.category]) {
                    categoryStats[item.category] = { totalSize: 0, totalSamples: 0, count: 0 };
                }
                categoryStats[item.category].totalSize += item.size;
                categoryStats[item.category].totalSamples += item.sampleCount;
                categoryStats[item.category].count += 1;
            });

            const labels = Object.keys(categoryStats).sort();
            const sizeData = labels.map(cat => categoryStats[cat].totalSize);
            const sampleData = labels.map(cat => categoryStats[cat].totalSamples);

            return {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Total Size (GB)',
                            data: sizeData,
                            backgroundColor: '#36A2EB80',
                            borderColor: '#36A2EB',
                            borderWidth: 1,
                            yAxisID: 'y'
                        },
                        {
                            label: 'Total Samples',
                            data: sampleData,
                            backgroundColor: '#FF638480',
                            borderColor: '#FF6384',
                            borderWidth: 1,
                            yAxisID: 'y1'
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Category'
                            }
                        },
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Total Size (GB)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Total Samples'
                            },
                            grid: {
                                drawOnChartArea: false,
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: 'Category Summary'
                        }
                    }
                }
            };
        }

        function createHistogram(data, field, logScale) {
            const values = data.map(item => item[field]).filter(v => v > 0);
            if (values.length === 0) {
                return { 
                    type: 'bar', 
                    data: { labels: [], datasets: [] }, 
                    options: {
                        responsive: true,
                        maintainAspectRatio: false
                    }
                };
            }
            
            const min = Math.min(...values);
            const max = Math.max(...values);
            
            let binCount = Math.sqrt(values.length);
            binCount = Math.min(20, Math.max(5, binCount));
            binCount = Math.floor(binCount);
            
            if (!Number.isFinite(binCount) || binCount <= 0) {
                binCount = 10;
            }
            
            const bins = Array(binCount).fill(0);
            const binLabels = [];
            const isLogX = logScale === 'x' || logScale === 'both';
            
            if (isLogX && min > 0) {
                const logMin = Math.log10(min);
                const logMax = Math.log10(max);
                const logBinSize = (logMax - logMin) / binCount;
                const binEdges = [];
                
                for (let i = 0; i <= binCount; i++) {
                    binEdges.push(Math.pow(10, logMin + i * logBinSize));
                }
                
                for (let i = 0; i < binCount; i++) {
                    const start = binEdges[i];
                    const end = binEdges[i + 1];
                    if (start < 1) {
                        binLabels.push(start.toExponential(1) + '-' + (end < 1 ? end.toExponential(1) : end.toFixed(2)));
                    } else {
                        binLabels.push(start.toFixed(2) + '-' + end.toFixed(2));
                    }
                }
                
                values.forEach(value => {
                    for (let i = 0; i < binCount; i++) {
                        if (value >= binEdges[i] && (i === binCount - 1 || value < binEdges[i + 1])) {
                            bins[i]++;
                            break;
                        }
                    }
                });
            } else {
                const binSize = (max - min) / binCount;
                
                for (let i = 0; i < binCount; i++) {
                    const start = min + i * binSize;
                    const end = min + (i + 1) * binSize;
                    binLabels.push(start.toFixed(2) + '-' + end.toFixed(2));
                }
                
                values.forEach(value => {
                    let binIndex = Math.floor((value - min) / binSize);
                    if (binIndex === binCount) binIndex = binCount - 1;
                    bins[binIndex]++;
                });
            }

            const fieldLabel = field === 'size' ? 'Size' : 'Sample Count';
            const fieldUnit = field === 'size' ? 'Size (GB)' : 'Sample Count';

            return {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: [{
                        label: fieldLabel + ' Distribution',
                        data: bins,
                        backgroundColor: '#FFCE5680',
                        borderColor: '#FFCE56',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            type: 'category',
                            title: {
                                display: true,
                                text: fieldUnit + (isLogX ? ' (Log Scale)' : '')
                            }
                        },
                        y: {
                            type: logScale === 'y' || logScale === 'both' ? 'logarithmic' : 'linear',
                            title: {
                                display: true,
                                text: 'Frequency'
                            }
                        }
                    },
                    plugins: {
                        title: {
                            display: true,
                            text: fieldLabel + ' Distribution'
                        }
                    }
                }
            };
        }

        function loadData(text) {
            currentData = parseData(text);
            filteredData = getFilteredData();
            updateCategoryFilter();
            updateStats();
            updateTable();
            createChart();
        }

        function refreshView() {
            filteredData = getFilteredData();
            updateStats();
            updateTable();
            createChart();
        }

        document.getElementById('techniqueFilter').addEventListener('change', refreshView);
        document.getElementById('typeFilter').addEventListener('change', refreshView);
        document.getElementById('chartType').addEventListener('change', createChart);
        document.getElementById('logScale').addEventListener('change', createChart);

        loadData(defaultData);
    </script>
</body>
</html>